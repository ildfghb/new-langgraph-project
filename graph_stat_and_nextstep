当前状态：
- LangGraph 图已经加入 `analyze_intent → resolve_fixture → fetch_fixture → call_model` 顺序链路，`State` 中新增 `intent` 与 `query_plan` 字段，模型提示会携带计划摘要。
- `fetch_fixture` 现在把完整 JSON 写入 Redis 第 4 库，只在 `state.fixture_payload` 中保留 `_kind=external_ref` 的摘要+引用（异常时自动回退为旧行为），显著降低了图状态的体积增长风险。
- 尚未实现 payload 批量裁剪、外部缓存失效治理或分阶段清理，因此一旦规划多请求场景，上下文爆炸的边界仍需验证，风险包括：
  * state 体积上升 → 触发序列化异常或 Redis 缓存压力。
  * Runtime 在迭代时要携带大量历史数据 → 模型提示难以聚焦，推理成本升高。
  * 调试/日志输出量激增 → 分析问题困难。
- 当前仍缺少单元测试与中间件式治理；如果未来要做多 API 深度分析，这一空白会放大维护成本。

下一步计划（重点保留上下文工程经验）：
1. **payload 裁剪与引用化深化**：在 `_prune_*` helper 中针对多端点（statistics/lineups/odds 等）提炼关键字段，除引用外再附带结构化 summary，必要时提供按引用回填的 helper，保证 LangGraph 状态可复用但依旧轻量。
2. **状态治理中间件**：封装一个 middleware 管道，在节点执行后统一执行：
   - 统计状态大小并在超过阈值时截断或写警告；
   - 对历史 payload 做分层清理（保留最新摘要、丢弃冗余字段）；
   - 动态注入提示词片段，让模型获知“已截断/如何取回原始数据”，保证回答连贯。
3. **循环调用策略**：为多端点流程设计“计划执行器”，每步结束后立即将大 payload 归档+清空，只把 summary 和引用写回 state；必要时在下一步前按引用异步取回，保证 LangGraph 上下文始终轻量。
4. **测试与监控**：补齐 `analyze_intent`、`_build_query_plan`、payload 裁剪逻辑的单元测试；同时加入日志钩子监控 state 长度，方便后续排查上下文爆炸的触发条件。
5. **交互约束**：在前端或模型回答层面引导用户分阶段提问（例如先确认比赛，再问统计与赔率），配合中间件阶段清理策略，把多维数据拆成多轮对话，减轻单次请求的上下文压力。
